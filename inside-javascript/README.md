> INSIDE JavaScript (인사이드 자바스크립트 내용 정리)  

# 01 자바스크립트 기본 개요  

## 소개 

기존의 JavaScript는 서버로부터 받은 데이터를 HTML, CSS를 통해 렌더링 해주는 보조적인 역할만 수행함.  
웹이 발전하면서, 서버에서 담당하던 역할들이 상당 부분 웹 브라우저로 이동하였다.  

이제 JavaScript를 통해 웹 개발뿐만 아니라 서버, 어플리케이션 개발이 모두 가능해졌다.  

## 핵심 개념  

### 객체  

기본 데이터 타입 : ```boolean```, ```number```, ```string```, ```null```, ```undefined```
를 제외한 모든 것은 객체로 다뤄진다.  

### 함수  

함수도 일반적인 객체보다 조금 더 많은 기능이 있는 **객체**로 다뤄진다.  

### 프로토타입  

모든 객체는 숨겨진 링크(Link)인 프로토타입을 가진다.  
객체를 생성한 **생성자**의 프로토타입 객체를 가리킨다.  
ES에서는 [[Prototype]]이라고 표현한다.  

### 실행 컨텍스트와 클로저  

Javascript에서는 어떤 과정을 거쳐 실행 컨텍스트를 만들고 그 안에서 실행이 이루어진다.  
실행 컨텍스트는 자신만의 유효 범위(Scope)를 갖는다.  
이 과정에서 클로저를 구현할 수 있다.  

## 객체지향 프로그래밍  

프로토타입 체인과 클로저로 상속, 캡슐화, 정보 은닉 등의 객체지향 개념을 소화할 수 있다.  

## 함수형 프로그래밍  

함수와 클로저의 특성을 이용하여 함수형 프로그래밍을 구현할 수 있다.  
난해하게 구현된다.  

## 단점  

* 느슨한 타입 체크 -> 런타임 오류로 이어짐  
* 전역 객체의 존재 -> 충돌 위험성  
* 모호한 설명 (ES3) -> ES5 승인으로 인해 해결됨  

# 02 자바스크립트 개발 환경  

# 03 자바스크립트 데이터 타입과 연산자  

**기본 타입과 참조 타입**으로 나뉜다.  

## 기본 타입  

**숫자, 문자열, 불린값, null, undefined**  

그 자체가 하나의 값을 나타낸다.  

느슨한 타입 체크 언어 -> ```var```이라는 한 가지 키워드로만 변수를 선언한다.  

### 숫자  

모든 숫자를 64비트 부동 소수점 형태로 저장한다. (C언어의 double)  

모든 숫자를 실수로 처리 한다. (``5/2 = 2.5```)  

소수 부분을 버린 정수만 구하고 싶다면 ```Math.floor()``` 자바스크립트 메서드를 이용한다.  

### 문자열  

큰 따옴표 또는 작은 따옴표로 정의한다.  

**한번 정의된 문자열은 읽기만 가능하지 변하지 않는다.**  

인덱스를 이용하여 배열과 같이 접근할 수 있다.  

### 불린 값  

true와 false  

### null 과 undefined  

**값이 비어있음**을 나타낸다.  

undefined 타입의 변수의 타입이자, 값 또한 undefined이다.  

null 타입의 변수는 명시적으로 값이 비어있음을 나타낸다.  

null 타입의 ```typeOf``` 결과는 ```object```이다.  
따라서 null 타입 변수인지를 확인할 때에는 일치 연산자(===)를 사용해서 변수의 값을 직접 확인해야 한다.   


## 참조 타입(객체)  

기본 타입을 제외한 모든 값은 객체다. (배열, 함수, 정규표현식 등)  

객체는 단순히 key:value와 같은 해시 혀앹의 프로퍼티들을 저장하는 컨테이너이다.  
참조 타입인 객체는 여러 개의 프로퍼티들을 포함할 수 있다.  
이 프로퍼티는 **기본 타입이 되거나, 또 다른 객체가 될 수 있다.**  

함수로 구현한 프로퍼티를 메서드라고 한다.  

### 객체 생성  

[JavaScript 객체 생성 방법 3가지](https://github.com/yeoseon/tip-archive/issues/47) 참고  

### 객체 프로퍼티의 읽기/쓰기/갱신  

대괄호([]) 또는 마침표(.) 표기법을 사용한다.  

```
foo['name'] (O)
foo.name (O)  
foo[name] (X)  
```  

객체 프로퍼티에 값을 할당할 때, 이미 존재하는 프로퍼티의 경우 값을 갱신하고, 존재하지 않을 경우 동적으로 생성한다.  

프로퍼티가 표현식이거나 예약어(```full-name```)일 경우는 반드시 대괄호 표기법을 사용해야 한다.  

### for in 문과 객체 프로퍼티  

for in 문을 객체에 사용하면 객체에 포함된 모든 프로퍼티에 대해 루프를 수행한다.  

### 객체 프로퍼티 삭제  

객체의 프로퍼티를 삭제할 뿐 객체 자체는 삭제하지 못한다.  

```
delete foo.nickname; (O)   
delete foo (X)
```

## 참조 타입의 특성  

기본 타입의 연산은 해당 값 자체로 이루어지지만, **객체는 모든 연산이 실제 값이 아닌 참조값으로 처리된다.**  

### 객체 비교   

동등 연산자(==)를 통한 객체 비교시에도 실제 프로퍼티 값이 아닌 참조값을 비교한다는 것에 주의한다.  
기본타입의 경우는 실제 프로퍼티 값이 같을 경우 true가 반환되지만, 참조타입은 객체의 참조값이 같아야 true가 반환된다.  

### 참조에 의한 함수 호출 방식  

기본 타입 : 값에 의한 호출(call by value) - 메서드를 통해 값을 보낼 경우, 복사된 값이 전달된다. 해당 메소드에서 값을 변경했을 경우 기존 메소드에 있던 실제 값은 변하지 않는다.  

참조 타입 : 참조에 의한 호출(call by reference) - 메서드를 통해 값을 보낼 경우 참조값이 전달된다. 즉, 가리키고 있는 참조 대상이 같기 때문에 해당 값을 변경하면 기존의 객체 값도 변경된다.  

## 프로토타입  

**모든 객체는 자신의 부모 역할을 하는 프로토타입([[Prototype]])이라는 숨겨진 프로퍼티를 가진다.**  

```foo```라는 객체에 ```name, age```라는 프로퍼티만을 선언하였는데, ```toString()``` 메소드를 사용할 수 있는 이유  
->  foo 객체의 부모 프로토타입에 정의되어 있기 때문  

모든 객체의 프로토타입은 **객체를 생성할 때 결정된다.**  
해당 프로토타입 객체에는 모든 객체에서 호출 가능한 자바스크립트 기본 내장 메서드가 포함되어 있다.  

객체를 생성할 때, 결정된 프로토타입 객체는 임의의 다른 객체로 변경할 수 있다.  
즉 부모 객체를 동적으로 바꿀  수 있다.  
이를 이용해서 객체 상속 등의 기능을 구현하기도 한다.  

## 배열  

크기를 지정하지 않아도 된다.  
어떤 위치에 어느 타입의 데이터를 지정해도 에러가 발생하지 않는다.  

### 배열 리터럴  

**대괄호[]**
```
var colorArr = ['orange', 'yellow'];
```

```key```없이 ```value```만 포함한다.  
인덱스를 통해 접근한다.  

### 배열의 요소 생성  

동적으로 배열 원소 추가 가능  
**아무 인덱스 위치에나 값을 동적으로 추가 가능**  

배열의 크기를 현재 배열의 인덱스 중가장 큰 값을 기준으로 정의한다.  
값이 할당되지 않은 인덱스의 요소는 ```undefined``` 값을 기본으로 가진다.  

모든 배열은 ```length``` 프로퍼티를 가지고 있다.  

### 배열의 length 프로퍼티  

**배열 내 가장 큰 인덱스 + 1**  

실제 메모리는 length 크기처럼 할당되지는 않음  

### 배열 표준 메서드와 length 프로퍼티  

배열에서 사용 가능한 다양한 표준 배열 메서드를 제공한다.(예. ```push()```)  

**이 배열 표준 메소드는 모두 ```length``` 프로퍼티를 기반으로 동작한다.**  

> **원래 길이가 7이었던 메소드의 ```length```값을 5로 임의로 바꾼다면?**  
> ```push()``` 메소드는 5번째 인덱스에 문자열을 추가하게 ㅗ딘다.  

### 배열과 객체  

**배열 역시 객체지만 일반 객체와는 차이가 있다.**  

```
// 배열  
var colorArray = ['red', 'blue'];

// 객체  
var colorObj = { 
    '0': 'red',
    '1': 'blue' 
};
```

* ```colorArray[1]```, ```colorObj[1]```로 모두 접근 가능  
    * ```colorObj['1']```로 해줘야 하지만, [] 연산자 내에 **숫자**가 사용될 경우 자동으로 문자열 형태로 바꿔주기 때문에 가능하다.  
* ```typeof``` 역시 둘다 ```object```로 일치  
* ```length``` 프로퍼티는 Object의 경우 ```undefined```  
* 배열 표준 메서드 (```push()```)의 경우, Object는 사용하지 못함  
    * 객체의 경우 **Object.prototype 객체**가 프로토타입니다.  
    * 배열의 경우 **Array.prototype 객체**가 프로토타입니다.  
    * **Array.prototype 객체**의 프로토 타입은 **Object.prototype 객체**이다. 따라서 배열은 Array와 Object의 프로토타입을 모두 사용할 수 있다.  


### 배열의 프로퍼티 동적 생성  

배열 원소 이외에서 객체처럼 동적으로 프로퍼티를 생성할 수 있다.  
**배열의 ```length``` 프로퍼티는 배열 원소의 가장 큰 인덱스가 변경되었을 경우에만 변경된다.  
프로퍼티를 아무리 추가해도 ```length```는 변경되지 않음  

### 배열의 프로퍼티 열거  

```for in``` 문을 사용하면, 해당 배열 객체 안에 들어있는 모든 프로퍼티를 차례대로 출력한다.  
따라서 불필요하게 원소 외의 프로퍼티들도 출력할 수 있으므로, ```for```문 사용을 권장하고 있다.  

### 배열 요소 삭제  

```delete```  
해당 요소의 값을 ```undefined```로 설정할 뿐, 원소 자체를 삭제하지는 않는다. 따라서 ```length``` 값은 변하지 않는다.  

```splice()``` 배열 메서드  
보통 요소들을 완전히 삭제할 경우 사용한다. 이를 사용할 경우 ```length```도 변한다.  
```
splice(start, deleteCount, item...)  
* start - 배열에서의 시작 위치(index + 1)    
* deleteCount - start에서 지정한 시작 위치로부터 삭제할 요소의 수  
* item - 삭제할 위치에 추가할 요소  
```

### Array() 생성자 함수  

배열은 일반적으로 배열 리터럴로 생성한다.  
**Array() 생성자 함수**를 통해 배열을 생성하는 것을 단순화 시킨 것이 배열 리터럴이다.  
생성자 함수를 이용할 때는 반드시 ```new```를 사용한다.  

* 호출할 때 인자가 1개이고 숫자인 경우 : 호출된 인자를 ```length```로 갖는 빈 배열 생성  
* 그 외 : 호출된 인자를 요소로 갖는 배열 생성  

### 유사 배열 객체  

```length``` 프로퍼티를 가진 일반 객체  

```apply()``` 메소드를 사용하여 표준 배열 메소드를 사용할 수 있다.  

```
var obj = {name: 'foo', length: 1};
Array.prototype.push.apply(obj, ['baz']);

console.log(obj); // (출력값) { '1', 'baz', name: 'foo', length: 2 }
```

## 기본 타입과 표준 메서드  

숫자, 문자열, 불린값에 대해 각 타입별로 호출 가능한 표준 메서드를 제공한다.  

기본 타입의 경우는 객체가 아닌데 어떻게 메소드를 호출하는가?  
-> 기본값은 메소드 처리 순간에 객체로 변환된 다음 각 타입별 표준 메서드를 수행하게 된다.  
메서드 호출이 끝나면 다시 기본값으로 복귀하게 된다.  

```
toExponential() //숫자를 지수 형태의 문자열로 변환  
charAt() // 문자열에서 인자로 받은 위치에 있는 문자 반환  
```  

## 연산자  

### + 연산자  

더하기 연산과 문자열 연결 연산  

### typeof 연산자  

피연산자의 타입을 문자열 형태로 리턴  

null, 배열 : object  
함수 : function  
undefined : undefined  

### ==(동등) 연산자와 ===(일치) 연산자  

```==``` : 피연산자의 타입이 다를 경우 같은 타입으로 변환한 후 비교  
```===```: 타입이 달라도 변환하지 않고 비교  

타입 변환에 따른 잘못된 결과를 얻을 수 있으므로 ```===```를 쓰자!  

### !! 연산자  

피연산자를 불린값으로 변환  

console.log(!!''); //false  
console.log(!!{}); //true : 객체는 값이 비어있는 빈 객체라도 true로 변환된다.  

# 04 함수와 프로토타입 체이닝  

## 함수 정의  

* 함수 선언문   
* 함수 표현식  
* Function() 생성자 함수  

### 함수 리터럴  

함수 선언문과 표현식 방법에 해당한다.  

```
function add(x, y) {
    return x + y;  
}
```

* 함수명은 선택 사항이다.(익명함수)  

### 함수 선언문 방식(function statement)  

함수 리터럴 중 **반드시 함수명이 정의되어야 하는** 방법  

### 함수 표현식 방식(function expression)  

**함수도 하나의 값처럼 취급한다.**  

함수 리터럴로 하나의 함수를 만들고, 이 생성된 함수를 변수에 할당하는 방법  

```
var add = function(x,y) {
    return x+y;
}
add(3,4);
```

* 함수 명은 선택사항이다.  
* ```add```는 **함수 변수**라고 부른다.  
* ```add```는 함수의 참조값을 가지므로, 또 다른 변수에도 그 값을 그대로 할당할 수 있다. 같은 곳을 참조하게 된다.  
* 이렇게 생성된 함수를 사용하려면 **함수 변수**를 사용해야 한ㄷ.ㅏ  

**익명 함수**
* 이름이 없는 함수 형태  
* 익명 함수의 호출은 함수 변수에 ()를 붙여서 기술하는 것으로 가능하다.  

**기명 함수의 예**  
```
var add = function sum(x,y) {
    return x+y;
}

console.log(add(3,4)); // 7
console.log(sum(3,4)); // sum is not defined  
```
* 함수 표현식에서 사용된 함수 이름이 외부코드에서 접근 불가능하다.  
* 함수 표현식에서 사용된 함수 이름은 정의된 함수 내부에서 재귀적으로 호출하거나, 디버거에서 함수를 구분할 때만 사용한다.  

> **함수 선언문과 표현식에서의 세미콜론**  
> 선언문 방식은 세미콜론을 붙이지 않지만, 표현식의 경우는 붙이는 것을 권장한다.  

### Function() 생성자 함수를 통한 함수 생성  

```
new Function(arg1, arg2, ... argN, functionBody)  

var add = new Function('x', 'y', 'return x+y');
```
거의 사용하지 않음. 

### 함수 호이스팅  

함수 생성의 3가지 방식에는 차이가 있다. 그 중하나가 함수 호이스팅이다.  

**함수 표현식만을 사용할 것을 권장하고 있다.**  
그 이유 중 하나가 함수호이스팅 때문   

**함수 선언문 형태로 정의한 함수의 유효 범위는 코드의 맨 처음부터 시작한다.**  
-> 함수를 사용하기 정네 반드시 선언해야 한다는 규칙을 무시하므로 코드의 구조를 엉성하게 만들 수 있다.  
-> 함수 호이스팅이 발생하는 원인 : **자바스트립트의 변수 생성과 초기화의 작업이 분리되서 진행되기 때문에**

**함수 표현식 형태는 호이스팅이 일어나지 않는다.**  
