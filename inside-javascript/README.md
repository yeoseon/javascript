> INSIDE JavaScript (인사이드 자바스크립트 내용 정리)  

# 01 자바스크립트 기본 개요  

## 소개 

기존의 JavaScript는 서버로부터 받은 데이터를 HTML, CSS를 통해 렌더링 해주는 보조적인 역할만 수행함.  
웹이 발전하면서, 서버에서 담당하던 역할들이 상당 부분 웹 브라우저로 이동하였다.  

이제 JavaScript를 통해 웹 개발뿐만 아니라 서버, 어플리케이션 개발이 모두 가능해졌다.  

## 핵심 개념  

### 객체  

기본 데이터 타입 : ```boolean```, ```number```, ```string```, ```null```, ```undefined```
를 제외한 모든 것은 객체로 다뤄진다.  

### 함수  

함수도 일반적인 객체보다 조금 더 많은 기능이 있는 **객체**로 다뤄진다.  

### 프로토타입  

모든 객체는 숨겨진 링크(Link)인 프로토타입을 가진다.  
객체를 생성한 **생성자**의 프로토타입 객체를 가리킨다.  
ES에서는 [[Prototype]]이라고 표현한다.  

### 실행 컨텍스트와 클로저  

Javascript에서는 어떤 과정을 거쳐 실행 컨텍스트를 만들고 그 안에서 실행이 이루어진다.  
실행 컨텍스트는 자신만의 유효 범위(Scope)를 갖는다.  
이 과정에서 클로저를 구현할 수 있다.  

## 객체지향 프로그래밍  

프로토타입 체인과 클로저로 상속, 캡슐화, 정보 은닉 등의 객체지향 개념을 소화할 수 있다.  

## 함수형 프로그래밍  

함수와 클로저의 특성을 이용하여 함수형 프로그래밍을 구현할 수 있다.  
난해하게 구현된다.  

## 단점  

* 느슨한 타입 체크 -> 런타임 오류로 이어짐  
* 전역 객체의 존재 -> 충돌 위험성  
* 모호한 설명 (ES3) -> ES5 승인으로 인해 해결됨  

# 02 자바스크립트 개발 환경  

# 03 자바스크립트 데이터 타입과 연산자  

**기본 타입과 참조 타입**으로 나뉜다.  

## 기본 타입  

**숫자, 문자열, 불린값, null, undefined**  

그 자체가 하나의 값을 나타낸다.  

느슨한 타입 체크 언어 -> ```var```이라는 한 가지 키워드로만 변수를 선언한다.  

### 숫자  

모든 숫자를 64비트 부동 소수점 형태로 저장한다. (C언어의 double)  

모든 숫자를 실수로 처리 한다. (``5/2 = 2.5```)  

소수 부분을 버린 정수만 구하고 싶다면 ```Math.floor()``` 자바스크립트 메서드를 이용한다.  

### 문자열  

큰 따옴표 또는 작은 따옴표로 정의한다.  

**한번 정의된 문자열은 읽기만 가능하지 변하지 않는다.**  

인덱스를 이용하여 배열과 같이 접근할 수 있다.  

### 불린 값  

true와 false  

### null 과 undefined  

**값이 비어있음**을 나타낸다.  

undefined 타입의 변수의 타입이자, 값 또한 undefined이다.  

null 타입의 변수는 명시적으로 값이 비어있음을 나타낸다.  

null 타입의 ```typeOf``` 결과는 ```object```이다.  
따라서 null 타입 변수인지를 확인할 때에는 일치 연산자(===)를 사용해서 변수의 값을 직접 확인해야 한다.   


## 참조 타입(객체)  

기본 타입을 제외한 모든 값은 객체다. (배열, 함수, 정규표현식 등)  

객체는 단순히 key:value와 같은 해시 혀앹의 프로퍼티들을 저장하는 컨테이너이다.  
참조 타입인 객체는 여러 개의 프로퍼티들을 포함할 수 있다.  
이 프로퍼티는 **기본 타입이 되거나, 또 다른 객체가 될 수 있다.**  

함수로 구현한 프로퍼티를 메서드라고 한다.  

### 객체 생성  

[JavaScript 객체 생성 방법 3가지](https://github.com/yeoseon/tip-archive/issues/47) 참고  

### 객체 프로퍼티의 읽기/쓰기/갱신  

대괄호([]) 또는 마침표(.) 표기법을 사용한다.  

```
foo['name'] (O)
foo.name (O)  
foo[name] (X)  
```  

객체 프로퍼티에 값을 할당할 때, 이미 존재하는 프로퍼티의 경우 값을 갱신하고, 존재하지 않을 경우 동적으로 생성한다.  

프로퍼티가 표현식이거나 예약어(```full-name```)일 경우는 반드시 대괄호 표기법을 사용해야 한다.  

### for in 문과 객체 프로퍼티  

for in 문을 객체에 사용하면 객체에 포함된 모든 프로퍼티에 대해 루프를 수행한다.  

### 객체 프로퍼티 삭제  

객체의 프로퍼티를 삭제할 뿐 객체 자체는 삭제하지 못한다.  

```
delete foo.nickname; (O)   
delete foo (X)
```

## 참조 타입의 특성  

기본 타입의 연산은 해당 값 자체로 이루어지지만, **객체는 모든 연산이 실제 값이 아닌 참조값으로 처리된다.**  

### 객체 비교   

동등 연산자(==)를 통한 객체 비교시에도 실제 프로퍼티 값이 아닌 참조값을 비교한다는 것에 주의한다.  
기본타입의 경우는 실제 프로퍼티 값이 같을 경우 true가 반환되지만, 참조타입은 객체의 참조값이 같아야 true가 반환된다.  

### 참조에 의한 함수 호출 방식  

기본 타입 : 값에 의한 호출(call by value) - 메서드를 통해 값을 보낼 경우, 복사된 값이 전달된다. 해당 메소드에서 값을 변경했을 경우 기존 메소드에 있던 실제 값은 변하지 않는다.  

참조 타입 : 참조에 의한 호출(call by reference) - 메서드를 통해 값을 보낼 경우 참조값이 전달된다. 즉, 가리키고 있는 참조 대상이 같기 때문에 해당 값을 변경하면 기존의 객체 값도 변경된다.  

## 프로토타입  

**모든 객체는 자신의 부모 역할을 하는 프로토타입([[Prototype]])이라는 숨겨진 프로퍼티를 가진다.**  

```foo```라는 객체에 ```name, age```라는 프로퍼티만을 선언하였는데, ```toString()``` 메소드를 사용할 수 있는 이유  
->  foo 객체의 부모 프로토타입에 정의되어 있기 때문  

모든 객체의 프로토타입은 **객체를 생성할 때 결정된다.**  
해당 프로토타입 객체에는 모든 객체에서 호출 가능한 자바스크립트 기본 내장 메서드가 포함되어 있다.  

객체를 생성할 때, 결정된 프로토타입 객체는 임의의 다른 객체로 변경할 수 있다.  
즉 부모 객체를 동적으로 바꿀  수 있다.  
이를 이용해서 객체 상속 등의 기능을 구현하기도 한다.  

## 배열  

크기를 지정하지 않아도 된다.  
어떤 위치에 어느 타입의 데이터를 지정해도 에러가 발생하지 않는다.  

### 배열 리터럴  

**대괄호[]**
```
var colorArr = ['orange', 'yellow'];
```

```key```없이 ```value```만 포함한다.  
인덱스를 통해 접근한다.  

### 배열의 요소 생성  

동적으로 배열 원소 추가 가능  
**아무 인덱스 위치에나 값을 동적으로 추가 가능**  

배열의 크기를 현재 배열의 인덱스 중가장 큰 값을 기준으로 정의한다.  
값이 할당되지 않은 인덱스의 요소는 ```undefined``` 값을 기본으로 가진다.  

모든 배열은 ```length``` 프로퍼티를 가지고 있다.  

### 배열의 length 프로퍼티  

**배열 내 가장 큰 인덱스 + 1**  

실제 메모리는 length 크기처럼 할당되지는 않음  

### 배열 표준 메서드와 length 프로퍼티  

배열에서 사용 가능한 다양한 표준 배열 메서드를 제공한다.(예. ```push()```)  

**이 배열 표준 메소드는 모두 ```length``` 프로퍼티를 기반으로 동작한다.**  

> **원래 길이가 7이었던 메소드의 ```length```값을 5로 임의로 바꾼다면?**  
> ```push()``` 메소드는 5번째 인덱스에 문자열을 추가하게 ㅗ딘다.  

### 배열과 객체  

**배열 역시 객체지만 일반 객체와는 차이가 있다.**  

```
// 배열  
var colorArray = ['red', 'blue'];

// 객체  
var colorObj = { 
    '0': 'red',
    '1': 'blue' 
};
```

* ```colorArray[1]```, ```colorObj[1]```로 모두 접근 가능  
    * ```colorObj['1']```로 해줘야 하지만, [] 연산자 내에 **숫자**가 사용될 경우 자동으로 문자열 형태로 바꿔주기 때문에 가능하다.  
* ```typeof``` 역시 둘다 ```object```로 일치  
* ```length``` 프로퍼티는 Object의 경우 ```undefined```  
* 배열 표준 메서드 (```push()```)의 경우, Object는 사용하지 못함  
    * 객체의 경우 **Object.prototype 객체**가 프로토타입니다.  
    * 배열의 경우 **Array.prototype 객체**가 프로토타입니다.  
    * **Array.prototype 객체**의 프로토 타입은 **Object.prototype 객체**이다. 따라서 배열은 Array와 Object의 프로토타입을 모두 사용할 수 있다.  


### 배열의 프로퍼티 동적 생성  

배열 원소 이외에서 객체처럼 동적으로 프로퍼티를 생성할 수 있다.  
**배열의 ```length``` 프로퍼티는 배열 원소의 가장 큰 인덱스가 변경되었을 경우에만 변경된다.  
프로퍼티를 아무리 추가해도 ```length```는 변경되지 않음  

### 배열의 프로퍼티 열거  

```for in``` 문을 사용하면, 해당 배열 객체 안에 들어있는 모든 프로퍼티를 차례대로 출력한다.  
따라서 불필요하게 원소 외의 프로퍼티들도 출력할 수 있으므로, ```for```문 사용을 권장하고 있다.  

### 배열 요소 삭제  

```delete```  
해당 요소의 값을 ```undefined```로 설정할 뿐, 원소 자체를 삭제하지는 않는다. 따라서 ```length``` 값은 변하지 않는다.  

```splice()``` 배열 메서드  
보통 요소들을 완전히 삭제할 경우 사용한다. 이를 사용할 경우 ```length```도 변한다.  
```
splice(start, deleteCount, item...)  
* start - 배열에서의 시작 위치(index + 1)    
* deleteCount - start에서 지정한 시작 위치로부터 삭제할 요소의 수  
* item - 삭제할 위치에 추가할 요소  
```

### Array() 생성자 함수  

배열은 일반적으로 배열 리터럴로 생성한다.  
**Array() 생성자 함수**를 통해 배열을 생성하는 것을 단순화 시킨 것이 배열 리터럴이다.  
생성자 함수를 이용할 때는 반드시 ```new```를 사용한다.  

* 호출할 때 인자가 1개이고 숫자인 경우 : 호출된 인자를 ```length```로 갖는 빈 배열 생성  
* 그 외 : 호출된 인자를 요소로 갖는 배열 생성  

### 유사 배열 객체  

```length``` 프로퍼티를 가진 일반 객체  

```apply()``` 메소드를 사용하여 표준 배열 메소드를 사용할 수 있다.  

```
var obj = {name: 'foo', length: 1};
Array.prototype.push.apply(obj, ['baz']);

console.log(obj); // (출력값) { '1', 'baz', name: 'foo', length: 2 }
```

## 기본 타입과 표준 메서드  

숫자, 문자열, 불린값에 대해 각 타입별로 호출 가능한 표준 메서드를 제공한다.  

기본 타입의 경우는 객체가 아닌데 어떻게 메소드를 호출하는가?  
-> 기본값은 메소드 처리 순간에 객체로 변환된 다음 각 타입별 표준 메서드를 수행하게 된다.  
메서드 호출이 끝나면 다시 기본값으로 복귀하게 된다.  

```
toExponential() //숫자를 지수 형태의 문자열로 변환  
charAt() // 문자열에서 인자로 받은 위치에 있는 문자 반환  
```  

## 연산자  

### + 연산자  

더하기 연산과 문자열 연결 연산  

### typeof 연산자  

피연산자의 타입을 문자열 형태로 리턴  

null, 배열 : object  
함수 : function  
undefined : undefined  

### ==(동등) 연산자와 ===(일치) 연산자  

```==``` : 피연산자의 타입이 다를 경우 같은 타입으로 변환한 후 비교  
```===```: 타입이 달라도 변환하지 않고 비교  

타입 변환에 따른 잘못된 결과를 얻을 수 있으므로 ```===```를 쓰자!  

### !! 연산자  

피연산자를 불린값으로 변환  

console.log(!!''); //false  
console.log(!!{}); //true : 객체는 값이 비어있는 빈 객체라도 true로 변환된다.  

# 04 함수와 프로토타입 체이닝  

## 함수 정의  

* 함수 선언문   
* 함수 표현식  
* Function() 생성자 함수  

### 함수 리터럴  

함수 선언문과 표현식 방법에 해당한다.  

```
function add(x, y) {
    return x + y;  
}
```

* 함수명은 선택 사항이다.(익명함수)  

### 함수 선언문 방식(function statement)  

함수 리터럴 중 **반드시 함수명이 정의되어야 하는** 방법  

### 함수 표현식 방식(function expression)  

**함수도 하나의 값처럼 취급한다.**  

함수 리터럴로 하나의 함수를 만들고, 이 생성된 함수를 변수에 할당하는 방법  

```
var add = function(x,y) {
    return x+y;
}
add(3,4);
```

* 함수 명은 선택사항이다.  
* ```add```는 **함수 변수**라고 부른다.  
* ```add```는 함수의 참조값을 가지므로, 또 다른 변수에도 그 값을 그대로 할당할 수 있다. 같은 곳을 참조하게 된다.  
* 이렇게 생성된 함수를 사용하려면 **함수 변수**를 사용해야 한ㄷ.ㅏ  

**익명 함수**
* 이름이 없는 함수 형태  
* 익명 함수의 호출은 함수 변수에 ()를 붙여서 기술하는 것으로 가능하다.  

**기명 함수의 예**  
```
var add = function sum(x,y) {
    return x+y;
}

console.log(add(3,4)); // 7
console.log(sum(3,4)); // sum is not defined  
```
* 함수 표현식에서 사용된 함수 이름이 외부코드에서 접근 불가능하다.  
* 함수 표현식에서 사용된 함수 이름은 정의된 함수 내부에서 재귀적으로 호출하거나, 디버거에서 함수를 구분할 때만 사용한다.  

> **함수 선언문과 표현식에서의 세미콜론**  
> 선언문 방식은 세미콜론을 붙이지 않지만, 표현식의 경우는 붙이는 것을 권장한다.  

### Function() 생성자 함수를 통한 함수 생성  

```
new Function(arg1, arg2, ... argN, functionBody)  

var add = new Function('x', 'y', 'return x+y');
```
거의 사용하지 않음. 

### 함수 호이스팅  

함수 생성의 3가지 방식에는 차이가 있다. 그 중하나가 함수 호이스팅이다.  

**함수 표현식만을 사용할 것을 권장하고 있다.**  
그 이유 중 하나가 함수호이스팅 때문   

**함수 선언문 형태로 정의한 함수의 유효 범위는 코드의 맨 처음부터 시작한다.**  
-> 함수를 사용하기 정네 반드시 선언해야 한다는 규칙을 무시하므로 코드의 구조를 엉성하게 만들 수 있다.  
-> 함수 호이스팅이 발생하는 원인 : **자바스트립트의 변수 생성과 초기화의 작업이 분리되서 진행되기 때문에**

**함수 표현식 형태는 호이스팅이 일어나지 않는다.**  

## 함수 객체 : 함수도 객체다  

### 함수도 객체다  

기본 기능인 코드 실행 뿐만 아니라 프로퍼티들을 가질 수 있다.  

* **함수 코드**는 함수 객체의 **[[Code]] 내부 프로퍼티**에 자동으로 저장된다.  
* 함수의 프로퍼티도 일반 객체처럼 ```.```을 이용해서 접근할 수 있다.  

### 함수는 값으로 취급된다.  

일급 객체  
* 리터럴에 의해서 생성  
* 변수나 배열의 요소, 객체의 프로퍼티 등에 할당 가능  
* 함수의 인자로 전달 가능  
* 함수의 리턴값으로 리턴 가능  
* 동적으로 프로퍼티를 생성 및 할당 가능  

이 특성을 이용하여 함수형 프로그래밍이 가능하다.  

#### 변수나 프로퍼티의 값으로 할당  

```
//변수에 함수 할당  
var foo = 100;
var bar = function() { return 100; };
console.log(bar()); // 100  

// 프로퍼티에 함수 할당  
var obj = {};
obj.baz = function() { return 200; }
console.log(obj.baz()); // 200  
```

```foo```와 달리 ```bar```는 **함수의 참조값**을 저장하고 있으므로, ```bar()```라고 했을 때, 실제 함수 호출이 가능하다.  

#### 함수의 인자로 전달  

```
var foo = function(func) {
    func();
}

foo(function() {
    console.log("메롱");
}
```

```foo()```함수를 실행할 때, 함수 리터럴 방식으로 생성한 **익명 함수**를 ```func```인자로 넘겼다.  

#### 리턴값으로 활용  

```
var foo = function() {
    return function() {
        console.log('메롱');
    };
};

var bar = foo();
bar();

// 출력 결과 : 메롱  
```

### 함수 객체의 기본 프로퍼티  

Javascript에는 일반 객체와는 다르게 함수 객체만의 표준 프로퍼티가 정의되어 있다.  
함수를 정의하고 ```console.dir()```을 통해 개발자도구에서 확인해본다.  

```arguments```, ```caller```, ```length``` 등과 같은 프로퍼티가 생성되어 있다.  

![image](https://user-images.githubusercontent.com/54384004/74785434-a825d580-52ed-11ea-865e-4ccd9348c162.png)  

* EC5 명세에서는 모든 함수가 **length** **prototype** 프로퍼티를 가져야 한다고 기술한다.  
* length, prototype 외의 name, caller, arguments, __proto__ 프로퍼티는 ECMA 펴준은 아니다. 
    * name 프로퍼티는 함수의 이름을 나타낸다. 익명함수라면 빈 문자열이 된다.  
    * caller 프로퍼티는 자신을 호출한 함수를 나타낸다. 호출하지 않았다면 null이다.  
    * arguments 프로퍼티는 함수를 호출할 때 전달된 인자값을 나타낸다. 호출되지 않으면 null이다.(뒤에 자세한 설명 참고)  
    * __proto__ 프로퍼티
        * 모든 객체는 **[[Prototype]]**이라는 내부 프로퍼티를 가진다.  
        * 자신의 부모 역할을 하는 프로토타입 객체를 가리킨다.  
        * 함수 객체의 부모역할을 하는 프로토타입 객체를 **Function.prototype 객체**라고 명명했다. 이 역시 함수 객체이다.  
        * __proto__역시 함수 객체이므로, name, callse, arguments 등과 같은 함수 객체의 프로퍼티를 가지고 있음을 확인할 수 있다.  

> **Function.prototype 객체의 프로토타입 객체는?**  
> Function.prototype 객체도 결국는 함수라고 정의하고 있다.  
> ECMA 에서는 예외적으로 Function.prototype 함수 객체의 무조는 모든 객체의 조상인 **Object.prototype 객체**라고 설명한다.  
> 참고로 Function.prototype 객체는 모든 함수들의 부모 역할을 하는 프로토타입 객체다.  
> Function.prototype 객체가 가져야 하는 프로퍼티를 다음과 같이 기술한다.  
> * constructor 프로퍼티  
> * toString() 메서드  
> * **apply(thisArg, argArray) 메소드**  
> * **call(thisArg, [, arg1 [,arg2,]]) 메소드**  
> * bind(thisArg, [, arg1[,arg2,]]) 메소드  


#### length 프로퍼티  

함수가 정상적으로 실행될 때 기대되는 인자의 개수  

#### prototype 프로퍼티  

**내부 프로퍼티인 [[Prototype]]과 혼동하지 말 것**  

> [[Prototype]]는 **객체 입장에서 자신의 부모 역할을 하는 프로포타입 객체**  
> prototype 프로퍼티는 **이 함수가 생성자로 사용될 때 이 함수를 통해 생성된 객체의 부모역할을 하는 프로토타입 객체**  

* 함수가 생성될 때 만들어진다.  
* constructor 프로퍼티 하나만 있는 객체를 가리킨다.  
    * 이 프로퍼티는 자신과 연결된 함수를 가리킨다.  

> **프로포타입 객체 네이밍**  
> 함수의 prototype 프로퍼티가 가리키는 프로토타입 객체는 
> 따로 네이밍 하지 않고 자신과 연결된 함수의 prototype 프로퍼티 값을 그대로 이용한다. (add.prototype)  

```
function myFunc() {
    return true;
}

console.dir(myFunc.prototype);
console.dir(myFunc.prototype.contructor);  
```
![image](https://user-images.githubusercontent.com/54384004/74786180-6302a300-52ef-11ea-9ad6-b198ac085e33.png)

* myFunc.prototype 객체는 constructor와 __proto__라는 두개의 프로퍼티가 있다.  
* myFunc.prototype.constructor 를 보면 프로토타입 객체와 매핑된 함수를 볼 수 있고, 이는 ```myFunc``` 함수를 가리키고 있다.  

**함수 객체와 프로토타입 객체**는 서로 밀접하게 연결되어 있다.  

이 개념은 이후 프로토타입과 프로토타입 체이닝을 이해할 기본 지식인만큼 꼭 기억하자.  
(page 90 그림 4-9 참고)  

## 함수의 다양한 형태  

### 콜백 함수  

함수 이름은 꼭 붙이지 않아도 된다. <- 익명함수  
익명함수의 대표적인 용도  

단지 함수를 등록하기만 하고, 어떤 이벤트가 발생했거나 특정 시점에 도달했을 때 시스템에서 호출되는 함수.  
또는 어떤 함수의 인자로 넘겨서 코드 내부에서 호출되는 함수 또한 콜백함수가 된다.  

```
// 대표적인 예 : 이벤트 핸들러  
window.onload = function() {
    alert('메롱');
};
```

### 즉시 실행 함수  

[TIL - 즉시실행함수](https://github.com/yeoseon/tip-archive/issues/43) 참고  

함수를 정의함과 동시에 바로 실행하는 함수  

```
(function(name) {
    console.log('이게 바로 즉시실행 함수' + name);
})('foo');
// 이게 바로 즉시실행 함수foo  
```

* 함수 리터럴을 괄호로 둘러 싼다.  
* 함수가 바로 호출될 수 있게 () 괄호 쌍을 마지막에 추가하고, 그 안에 값을 추가하면 인자로 넘겨진다.  
* 같은 함수를 다시 호출할 수 없다. -> **최초 한번의 실행만을 필요로 하는 초기화 코드 부분** 등에 사용할 수 있다.  
* jQuery 와 같은 보통의 라이브러리들도 모든 코드가 즉시실행함수로 둘러싸여져 있다.  
    * 변수 유효범위 특성 때문이다.  
        * 함수 유효범위를 지원한다.  
        * 기본적으로 변수를 선언할 경우 프로그램 전체에서 접근할 수 있는 전역 유효범위를 가진다.  
        * 그러나 함수 내부에서 ```var```를 통해 정의된 변수들은 함수 코드 내부에서만 유효하다.(```var```를 통하지 않으면 함수 내부여도 전역에서 접근 가능하다.)  
    * 이 때문에, 여러 라이브러리를 쓰더라도 각 함수만의 유효범위를 갖게되어 변수명이 충돌 되는 등의 문제를 방지하지 않을 수 있다.(전역 네임스페이스를 더럽히지 않는다.)  

> **즉시 실행 함수 패턴**  
> 라이브러리 코드가 로드되면 실행되는 초기화 작업시 많이 사용된다.  

### 내부 함수  

함수 코드 내부에서도 다시 함수 정의가 가능하다.  
내부 함수는 클로저를 생성하거나 부모함수 코드에서 외부에서의 접근을 막고 독립적인 헬퍼 함수를 구현하는 용도 등으로 사용된다.  

```
function parent() {
    var a = 100;
    var b = 200;

    function child() {
        var b = 300;

        console.log(a);
        console.log(b);
    }
    child();
}

parent();
child();

//100
//300
//child is not defined  
```

#### 내부 함수에서는 자신을 둘러싼 부모 함수의 변수에 접근이 가능하다.  
* 스코프 체이닝 때문이다.  

#### 내부 함수는 일반적으로 자신이 정의된 부모 함수 내부에서만 호출이 가능하다.  
* 함수 스코핑 때문이다.  
* 함수 외부에서도 특정 함수 스코프 안에 선언된 내부 함수를 호출하려면, 내부함수를 외부로 리턴하는 등의 방법을 사용하여 가능하기도하다.  
    ```
    function parent() {
        var a = 100;

        var child = function() {
            console.log(a);
        }

        return child;
    }
    var inner = parent();
    inner();

    //100  
    ```  

    함수의 참조값을 가지므로 가능한 일  

    실행이 끝난 parent()와 같은 부모 함수 스코프의 변수를 참조하는 inner()와 같은 함수를 클로저라고 한다.  

### 함수를 리턴하는 함수  

일급 객체이므로 리턴할 수 있다.  

## 함수 호출과 this  

### arguments 객체  

JavaScript 에서는 함수를 호출할 때 함수 형식에 맞춰 인자를 넘기지 않더라도 에러가 발생하지 않는다.  

인자 보다 적게 함수를 호출했을 경우, 넘겨지지 않은 인자는 ```undefined```되고, 더 많은 인자를 넘길 경우 나머지 인자는 무시된다.  

이러한 특성 때문에 **런타임시에 호출된 인자의 개수를 확인하고 이에 따라 동작을 다르게 해줘야하는 경우가 있다.**  
이에 사용되는 것이 바로 arguments 객체이다.  

함수를 호출할 때 넘긴 인자들이 배열 형태로 지정된 객체를 의미한다.  
이는 **유사 배열 객체**이다.  

다음과 같이 세 부분으로 구성되어 있다.  
* 넘겨진 인자(배열 형태)  
* length : 인자의 개수  
* callee : 이 함수의 참조값  

### 호출 패턴과 this 바인딩  

